!!Traits: reusable class fragments
@cha:traits

Traits are collections of methods that can be reused by multiple classes that are not related by inheritance.  Although Pharo does not provide multiple inheritance, it supports a mechanism called Traits for sharing class fragments (behavior and state) across unrelated classes.
Since Pharo 7.0, traits can also hold state.

Using traits allows one to share code between different classes without duplicating code.
This makes it easy for classes to have a unique superclass, yet still ''reuse'' useful behavior with otherwise unrelated classes.

As we will show later, traits propose a way to compose and resolve conflicts in disciplined manner. With traits this is not the latest loaded method that wins as this happens with language such as Groovy. With Traits, the composer (be it a class or a trait) takes always precedence and can decide in its context
how to resolve a conflict: Methods can be removed or accessible under a new name at composition time.

!!! A simple trait

The following code defines a trait. The ==uses:== clause in an empty array indicating that this trait is not composed of other traits.

[[[label=scr:flying|caption=A simple trait.
Trait named: #TFlyingAbility
	 uses: {}
	 package: 'Traits-Example'
]]]

Traits can define methods.
The trait ==TFlyingAbility== defines a single method ==fly==.

[[[
TFlyingAbility >> fly 
	^ 'I''m flying!'
]]]

Now we define a class called ==Bird== that uses the trait. 
The class has then the ==fly== method.

[[[
Object subclass: #Bird
	uses: TFlyingAbility
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Traits-Example'
]]]

Instances of the class ==Bird== know how to answer to  the message ==fly==. 

[[[
| b |
b := Bird new.
b fly
>>> 'I''m flying!'
]]]


!!! Using a required method
The trait methods do not have to fully define a behavior. A trait method 
can invoke methods that are available on the class using it.

Here the method ==greeting== of the trait ==TGreetable== in invoking the method ==name== that is not defined
in the trait itself.
In such a case the class using the trait will have to implement such ''required'' method.

[[[
Trait named: #TGreetable
	 uses: {}
	 package: 'Traits-Example'
]]]

[[[
TGreetable >> greeting
	^ 'Hello ', self name
]]]

Notice that ==self== in a trait represents the receiver of the message. 
Nothing changes compared to classes and default methods.

[[[
Object subclass: #Person
	uses: TGreetable
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Traits-Example'	
]]]

Now in the class ==Person== we define the method ==name==
and the ==greeting== method will invoke it.

[[[
Person >> name 
	^ 'Bob'
]]]

[[[
Person new greeting
>>> 'Hello Bob'
]]]



!!! Self in a trait is the message receiver
The question of the status of ==self== in a trait may be raised. 
However, there is not difference between ==self== used in a method defined in a class or defined in a trait. 
==self== always represents the receiver. The fact that the method is defined in a class or a trait
has no influence on ==self==. 

[[[
Trait named: #TInspector
	uses: {}
	package: 'Traits-Example'
]]]

[[[
TInspector >> whoAmI
	^ self
]]]

[[[
Object subclass: #Foo
	uses: TInspector
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Traits-Example'

]]]

[[[
| foo |
foo := Foo new.
foo whoAmI == foo
>>> true
]]]


!!! Trait state
Since Pharo 7.0 traits can also define instance variables.
Here the trait ==TCounting== defines an instance variable named ==#count==.

[[[
Trait named: #TCounting
	instanceVariableNames: 'count'
	package: 'Traits-Example'
]]]

The trait can initialize its state by redefining the method ==initialize== followed by the class named.
Here the trait ==TCounting== defines the method ==initializeTCounting==.

[[[
TCounting >> initializeTCounting
	count := 0
]]]

[[[
TCounting >> increment 
	count := count + 1.
	^ count
]]]

The class ==Counter== uses the trait ==TCounting==: its instances will have an instance variable named ==count==.
 
[[[
Object subclass: #Counter
	uses: TCounting
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Traits-Example'
]]]

To initialize correctly ==Counter== instances, the ==initialize== method of the class ==Counter== should invoke the previously defined trait method ==initializeTCounting==.

[[[
Counter >> initialize
	self initializeTCounting
]]]

The following code shows that we created a counter and it has a well initialized instance variable.

[[[
Counter new increment; increment
>>> 2
]]]

!!! A class can use two traits

A class is not limited to use only one traits. It can use several traits.
Imagine that we define another trait called ==TSpeakingAbility==.

[[[
Trait named: #TSpeakingAbility
	uses: {}
	package: 'Traits-Example'
]]]

This trait defined a method ==speak==.

[[[
TSpeakingAbility >> speak
	^ 'I''m speaking!'
]]]

Now we define a second trait ==TFlyingAbility==.

[[[
Trait named: #TFlyingAbility
	instanceVariableNames: ''
	package: 'Traits-Example'
]]]

This trait defines a method ==flying==.

[[[
TFlyingAbility >> fly

	^ 'I''m flying'
]]]

Now the class ==Duck== can use both traits ==TFlyingAbility== and ==TSpeakingAbility==
as follows: 

[[[
Object subclass: #Duck
	uses: TFlyingAbility + TSpeakingAbility 
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Traits-Example'
]]]

Instances of the class ==Duck== get all the behavior from the two traits. 
[[[
| d |
d := Duck new.
d speak
>>> 'I''m speaking!'
d fly
>>> 'I''m flying!'
]]]


!!! Overriding method takes precedence over trait methods

A method originating from a trait acts as if it would have been defined in the class using that trait. 
Now the user of a trait (be it a class or another trait) can always redefine the method originating from the trait
and the redefinition takes precedence in the user over the method of trait. 

Let us illustrate it.
In the class ==Duck== we can redefine the method ==speak== to do something else and for example send the message ==quack==.

[[[
Duck >> quack
	^ 'QUACK'
]]]

[[[
Duck >> speak
	^ self quack
]]]

It means that
- the trait method ==speak== is not accessible from the class anymore, and
- the new method is used in place, even by method sending the message ==speak==.

[[[
Duck new speak
>>> 'QUACK'
]]]

We define a new method call ==doubleSpeak== as follows:

[[[
TSpeakingAbility >> doubleSpeak
	^ 'I double: ', self speak, ' ', self speak
]]]

The following example shows that the locally redefined version of the method ==speak== of the class ==Duck== in place 
of the one of the trait ==TSqueakingAbility==.

[[[
Duck new doubleSpeak
>>> 'I double: QUACK QUACK'
]]]


!!! Accessing overridden trait methods

Sometimes you want to override a method from a trait and at the same time still being able to access the overridden 
method. This is possible by creating an alias to the overridden method in the class trait composition clause using the ==\@== and ==\-\>== operators
as follows: 

[[[
Object subclass: #Duck
	uses: TFlyingAbility + TSpeakingAbility @{#originalSpeak -> #speak}
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Traits-Example'
]]]

Note that the arrow means that the new method name is the same as the old one. 
Here we say that ==originalSpeak== is the new name of ==speak==.

The overridden method can be accessed using its new name as a default method. 
Here we define the method ==differentSpeak== calling ==originalSpeak==.

[[[
Duck >> differentSpeak
	^ self originalSpeak, ' ', self speak
]]]

[[[
Duck new differentSpeak
>>> 'I''m speaking! QUACK'
]]]

Pay attention that an alias is not a full method rename. 
Indeed if the overridden method is recursive, it will not call it new name.
An alias just give a new name to an existing method, it does not change its definition. 


!!! Handling conflict

It may happen that two traits used in the same class define the same method. 
This situation is a conflict.
To solve conflict, there are two strategies:
# Using the ==\-== operator, you can exclude the conflicting method from the trait defining, 
# or defining the conflicting method locally. In such a case, the conflicting methods are overridden and they can be made accessible as previously explained with the ==\@== operator.

Here is an example. Let us define another trait

[[[
Trait named: #THighFlyingAbility
	instanceVariableNames: ''
	package: 'Traits-Example'
]]]

[[[
THighFlyingAbility >> fly

	^ 'I''m flying high'
]]]

When we define the class ==Eagle== that uses the two traits ==THighFlyingAbility== and ==TFlyingAbility==, we will have a
conflict when sending the message ==fly== because the runtime does not know which method to execute. 

[[[
Object subclass: #Eagle
	uses: THighFlyingAbility + TFlyingAbility 
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Traits-Example'
]]]

[[[
Eagle new fly
>>> 'A class or trait does not properly resolve a conflict between multiple traits it uses.'
]]]

!!! Conflict resolution: excluding a method

To solve the conflict we can simply exclude during the composition the ==fly== method from the trait ==TFlyingAbility==.

[[[
Object subclass: #Eagle
	uses: THighFlyingAbility + (TFlyingAbility - #fly)
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Traits-Example'
]]]

Now there is only one ==fly== method.

[[[
Eagle new fly
>>> 'I''m flying high'
]]]

!!! Conflict resolution: redefining the method

To solve the conflict we can simply redefine the conflicting method in the class using the traits. 

[[[
Object subclass: #Eagle
	uses: THighFlyingAbility + TFlyingAbility
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Traits-Example'
]]]

Now there is only one ==fly== method.

[[[
Eagle >> fly

	^ 'Flying and flying high'
]]]

[[[
Eagle new fly
>>> 'Flying and flying high'
]]]

You can also access the overridden method by creating an alias as explained below. 


!!! Conclusion

Traits are groups of methods and state that can be reused in different classes, supporting this way 
a kind of multiple inheritance in the context of a single inheritance language. 
A class can be composed of several traits. And traits can define methods having the same name, leading to a conflict.

To handle conflict, the class can redefine the class locally: local methods take precedence over trait ones, or exclude
a conflicting method. Finally a overridden method (redefine in a class) can be accessed via an alias created at the level of the 
class use.

